
### Решение Макса:

```go
package main

func twoSum(nums []int, target int) []int {
	// ключ - число, значение - на какой позиции встретили число
	usedNums := make(map[int]int)
	for idx, secondNum := range nums {
		// firstNum - число, которое должны были встретить раньше
		//   чтобы текущее число (secondNum) + firstNum дало в сумме target
		firstNum := target - secondNum
		// если firstNum уже встречали в массиве, значит мы нашли
		//   пару чисел, дающие в сумме target и возвращаем их индексы
		if pos, found := usedNums[firstNum]; found {
			return []int{pos, idx}
		}
		usedNums[secondNum] = idx
	}
	return []int{}
}
```
___
### Runtime: 6ms; Memory: 4.26 MB Beats: time: 66.06%; memory: 30.28%
___
### Решение:
1. Так для решения будет использоваться hash-table - необходимо определить что будет содержать её ключ(key) и значение(value):
   * key - число из массива;
   * value - позиция, на которой число(key) было встречено.
2. Идём по массиву, берём жлементы по очереди и проверяем какое число должно быть вторым, чтобы в сумме получился target.
3. Проверяем на наличие второго числа в hash-table, если оно есть - записываем его позицию и позицию первого элемента и возвращаем ***ответ***,\
**ИНАЧЕ** записываем позицию первого жлемента в hash-table и повторяем шаги со 2го для следующего жлемента. 
___
### Как считали память:
Так как самое затратное по времени - один проход по масиву, состоящему из n элементов, время: **О(n)**.\
Так как в худшем случае в таблицу будут добавлены все элементы массива, кроме последнего, получится: O(n-1) = **O(n)**.\
ТАКЖЕ: **Амортизированная сложность** hash-table принята за **O(n)**,\
ХОТЯ, в реальности могут быть случаи, когда ТОЛЬКО сложность операций hash-table = O(n) (пример: реалокация данных)  


